# Часть 1. Описание подхода к верификации корректности аллокатора

## Ведение

В этой части я постараюсь максимально подробно объяснить общие идеи лежащие в основе подхода к верификации менеджера памяти.

## Достаточно ли логики Хоара для верификации?

Предполагаю, что читатель уже знаком с логикой Хоара и её использованием для доказательства свойств императивных программ.
Тем, кто ещё не знаком с таким подходом к верификации свойств программ могу порекоммендовать хоть и страрую, но во многом
просто замечательную книгу Дэвида Гриса "Наука программирования". Найти бумажный вариант этой книги уже очень непросто, но в интернете
есть её сканы довольно хорошего качества. По понятным причинам я привести ссылки не могу, но желающие сами смогут их быстро найти.

Логика Хоара позволяет нам через аннотацию кода пред- и пост-условиями (в совокупности с правилами вывода), плюс ещё инвариантами
для циклов, доказывать правильность предикатов в пред- и пост-условиях.

Таким образом используюя логику Хоара мы можем доказывать свойства кода и их сохранение при выполнении программы.

Это всё хорошо. Но возникает вопрос: а какие свойства нужно доказывать? Как их сформулировать и формализовать?

В случае с простыми свойствами, например, отсутствие выхода за границы массива, отсутствие переполнений при арифметических
операциях и тд. всё понятно. Это примитивные свойства безопасности кода и их формулировка и формализация проблем не вызывает.

Простейшие приедикаты корректности простых структур данных, например, то что массив отсортирован функцией сортировки, уже
сложнее сформулировать и формализовать, но всё ещё реально это сделать не прибегая ни к какаим другим методам, кроме логики
Хоара.

Но как быть с функциональной корректностью высокого уровня? Ведь полностью безопасная программа может просто неправильно работать,
то есть сам алгоритм просто-напросто может быть некорректен.

## Функциональная корректность

В данном случае под функциональной корректностю я подразумеваю корректность свойтсв алгоритма в целом, как набора высших
абстрактных функций и операций. То есть, программа реализует некий алгоритм (совокупность алгоритмов), который реализуют
высшие функции, например функции работы с памятью, и этот функционал должен быть реализован корректно в определённом смысле.

Что же подразумевается под корректностью?

Под корректностью здесь я понимаю соответствие алгоритма некоторым требованиям, которые чётко и формально сформулированы и
которые можно проверить/доказать со всей математической строгостью.

Тут становится очевидно, что кроме верификации свойств кода программы, нам нужно ещё сформулировать и формализовать свойства
алгоритма, затем проверить/доказать соответсвие алгоритма этим свойствам, отразить свойства корректности алгоритма
в свойства кода (выраженные в логике Хоара) и далее уже доказывать сответсвие кода этим свойствам.

То есть, грубо говоря, верификация программы - это строгое докозательство её соответствия чему-то. И вот это что-то нужно тоже чётко
сформулировать, сформулировать его свойства и доказать соответсвие этого чего-то сформулированным свойствам.

## Формулировка свойств

В случае менеджера памяти довольно очевидно, что корректность его работы связана со структурой памяти и сохранением некоторых
свойств структуры памяти при работе с ней.

Соответственно, если есть структура памяти и она как-то меняется при работе менеджера памяти, то есть набор операций по
изменению этой структуры.

Таким образом естественно получается формулировать свойства алгоритма менеджера памяти через определение структуры памяти,
операций над этой структурой и свойств структуры и операций.

## Абстрактная модель

Абстракная модель - это такая модель для проверки нужных нам свойств алгоритма, где убраны все лишние детали, которые
не влияют на проверямые свойства. Например, при моделировании структуры памяти, нам неважны конкретные размеры указателей,
размер машинного слова и тд. Более того, нам даже не важно конкретное представление адресов и размеров областей памяти.
Нам важны только правильные отношения между этими объектами модели.

Если мы всё это формализуем, то получим формальную абстрактную модель памяти, и сможем проверить нужные нам
свойства алгоритма на этой модели.

Для проверки свойств алгоритма нужно будет ещё формализовать операции, формализовать свойства как этих операций
так и корректности алгоритма (свойства памяти, которые должны сохранять операции), после этого выразив основные
функции алгоритма через эти операции мы сможем проверить корректность работы алгоритма.

Затем мы этот алгоритм реализуем в коде таким образом, чтобы операции кода по работе с памятью точно соответствовали операциям
абстрактного алгоритма (это соответствие будет строго доказано) и получим математически корректную реализацию алгоритма
с заданными свойствами.

Подробнее о связи абстрактной модели с конкретной моделью для верификации и с кодом будет написано чуть позже в этой части.

## Формальная спецификация

Нужна ли формализация спецификаций?

Очевидно, что да, если мы хотим быть уверены, что сформулированные нами высшие свойства менеджера памяти правильно выбраны
и корректно сформулированы. В противном случае можно формально доказать соответствие кода некорректным требованиям и
получить формально верифицированный, но неправильно работающий код. А это, думаю, не то что мы хотели бы в случае такого
базового ПО, как менеджер памяти.

Формальная спецификация в нашем случае - это как раз и есть формальная абстракная модель с формализованными операциями и
формализованными свойствами.

Формализовать всё это можно разными способами, от формализации в логиках высшего порядки и использования ATP (automated theorem provers),
например, Isabelle/HOL, Coq и др., до использования более гуманных вариантов - model-checkers/model-finders.

Так как в данном случае у нас основной акцент на структуру и её свойства, операций немного и они простые, то удобнее всего
будет использовать формализацию в **Alloy** (реляционная логика первого порядка с операциями объединения и транзитивного замыкания
отношений) и **Alloy Analyzer**, как инструмент для работы с этой формализацией.

Соответственно после валидации формальной спецификации мы можем быть уверены в соответствии алгоритма нужным нам свойствам.

Так как эта часть просто обзорная, то формулировка конкретных свойств и разработка формальной спецификации будет
в следующей части.

## Преимущества формальных спецификаций

Так как формальные спецификации обычно весьма абстрактные, то они как правило небольшого объёма.
С ними относительно просто работать.

И на них можно быстро и просто промоделировать основные свойства системы до начала написания кода.

Ввиду простоты и небольшого объёма, формальные спецификации легко менять, дополнять, рефакторить и тд.

При моделировании системы и проверки её свойств на формальных спецификациях можно получить серьёзный
выигрыш в объеме работы над основным кодом.

Если очень хороший пример из промышленности, когда использование формальных спецификаций позволило
оптимизировать архитектуру системы и уменьшить объём кода при сохранении функционала в 10 раз! (todo: ссылка наOpenCOM RTOS)

Конечно же, не всегда имеет смысл разрабатывать формальные спецификации, и важно понимать, когда и для каких
частей проекта формальные спецификации могут дать выигрыш.

Если проект большой, время жизни планируется довольно приличным и стоимость архитектурных ошибок высока, то, скорее
всего, формальные спецификации на базовый функционал и архитектуру могут быть очень полезны, помогая избежать
наличия дорогостоящего рефакторинга с целью исправления архитектурных проблем.

## Формальная спецификация и код

Для того, чтобы верифицировать код, нужна более конкретная модель, выраженная в логике Хоара.

В данном случае мной был использован подход через создание Ghost-модели. Эта модель более конкретная, чем модель в
формальной спецификации, она сохраняет все свойства формальной абстрактной модели, уточняя их и, добавляет новые
свойства, которые нужны для верификации кода.

Ghost-модель менеджера памяти содержит ровно те же базовые операции по работе с памятью, что и абстрактная модель, только
уточненные. Так же Ghost-модель содержит все свойства абстрактной формальной модели и имеет дополнительные, необходимые
для формальной верификации кода.

## Формальная конкретная модель

Формальная конкретная модель - это Ghost-код, реализуюший конкретную упрощённую модель для алгоритма менеджера памяти.
Например, работа с памятью заменяется работой с массивом стркутур, соответствующих блокам памяти, и тд.

На этой Ghost-модели доказывается сохранение свойств абстрактной модели и тд.

Ghost-код в релизный код ПО не попадает, он считается виртуальным и существует только во время верификации и частично отладки.

В этой Ghost-модели уже используются конкретные типы данных для адресов, размеров и пр. Конкретные обычные структуры и тд.

Основное отличие от рабочего кода - это максимальное упрощение, которое ещё сохраняет нужные нам свойства.

[поясняющая картнка отображения абстрактной модели в конкретную]

Почему бы не начать сразу с Ghost-модели, без формальных спек?

Проблема в том, что так как Ghost-модель - это логика первого порядка, то многие высокоуровневые свойства в ней невыразимы, а те,
что выразимы, могут быть очень сложно доказуемы.

Поэтому проще всего сначала промоделировать систему в рамках высокоуровневой формальной спецификации, сформулировать и проверить
нужые нам свойства высокого уровня и затем их просто перенести в формальную конкретную модель.

## Вeрификация кода на основе Ghost-модели

Наконец-то добрались до вопросов связанных уже с верификацией самого кода.

Как верифицировать код (его функциональную корректность), если у нас есть Ghost-модель?

У нас есть уверенность в Ghost-модели, но нет уверенности (пока) в коде.

Как перенести свойства Ghost-модели в код?

Делается это через отражение функций в коде на функции и операции в Ghost-модели, отражение отношений между
объектами в коде в отношения между объектами модели.

Таким образом у нас получается любая операция в коде над памятью отражается в операцию в Ghost-модели.

И в пре- и пост- условия в коде мы ставим предикат сохранения валидности Ghost-модели, то есть сохранения её
свойств.

Никакие операции в коде над структурами памяти не должны идти в обход Ghost-модели.

В данном случае это достигается лекго введением всего двух функций для работы с реальными блоками памяти,
через которые идёт вся работа со структурами в памяти:
  * Store_Block - запись блока в память
  * Load_Block - загрузка блока из памяти

Посмотрим чуть подробнее на декларации этих процедур:

### Процедура Store_Block

Вот декларация:

     procedure Store_Block (Ctx    : TC.Context;
                            B      : Block)
     with
       Global => (Proof_In => MC.State),
       Pre =>
         Valid_Block (Ctx, B) and then
         MC.Has_Model (Ctx) and then
         MB.Valid (MC.Get_Block_Model (Ctx)) and then
         MB.In_Model (MC.Get_Block_Model (Ctx), To_Model (Ctx, B));

Аспект **Global** говорит о том, что в режиме формальной верификации мы читаем глобальное состояние формальной Ghost-модели.

Посмотрим подробнее на предикат предусловия.

Он говорит о том, что мы можем вызвать эту процедуру для изменения структуры в памяти только если:

  * Заголовок блока валиден, то есть адрес, размер и пр. соответсвуют ограничениям в контектсте аллокатора **Ctx**.
  * Для заданного контектса аллокатора определена формальная Ghost-модель: ```MC.Has_Model (Ctx)```
  * Эта Ghost-модель валидна для блоков в памяти (общая Ghost-модель состоит из двух подмоделей, для моделирования
    блоков в памяти и для моделирования работы со списками свободных блоков): ```MB.Valid (MC.Get_Block_Model (Ctx))```
  * И реальный блок **B** имеет отражение в Ghost-модели: ```MB.In_Model (MC.Get_Block_Model (Ctx), To_Model (Ctx, B))```,
    где функция **To_Model** - это Ghost-функция отображения реальных блоков в Ghost-блоки модели.

При таком предусловии получается, что записать данные конкретного блока **B** в память мы можем, только если этот
блок отражён в валидной Ghost-модели.

Таким образом, у нас поддерживается соответсвие реальной структуры в памяти её Ghost-модели. И валидность модели свидетельствует
о валидности структуры памяти.

### Процедура Load_Block

Эта процедура чуть интереснее. При загрузке произвольного блока из памяти, как мы можем знать, что этот блок имеет
отражение в Ghost-модели? У нас же нет пока информации о блоке, чтобы проверить, что его отражение есть в модели.

Тут легко можно заметить, что из основных свойств структур блоков, следует, что они находятся в тех или иных списках.
В списке свободных или просто в общем списке блоков в памяти. За исключением краевых блоков, следующий блок, например, должен
быть по адресу address + size текущего.

То есть, если у нас есть блоки, которые уже имеют отражение в Ghost-модели, то по условиям корректности модели (которые
подробнее будут сформулированы в следующих частях), связанные с ними блоки тоже должны быть в Ghost-модели.

Значит, при загрузке блока из памяти, мы должны просто удостоверится, что у какого-то блока в Ghost-модели есть такой адрес.

И так как нет никаких способов кроме Store_Block записывать блоки в память, то мы можем быть уверены, что по этому
адресу лежит корректный блок, который уже имеет отражение в Ghost-модели.

     procedure Load_Block (Ctx  : TC.Context;
                           Addr : BT.Aligned_Address; 
                           B    : out Block)
     with 
       Global => (Proof_In => MC.State),
       Pre => 
          MC.Has_Model (Ctx) and then
          MB.Valid (MC.Get_Block_Model (Ctx)) and then
          MB.Address_In_Model (MC.Get_Block_Model (Ctx), Addr),
       Post =>
          B.Address = Addr and then
          Valid_Block (Ctx, B) and then
          MB.In_Model (MC.Get_Block_Model (Ctx), To_Model (Ctx, B));

В пред-условии нам нужно всего-лишь удостовериться, что есть Ghost-модель для данного контекста аллокатора, она валидна и
в этой модели есть какой-то блок с заданным адресом.

Соответственно, в пост-условии записано, что загруженный блок валиден и имеет отражение в Ghost-модели.

* Верификация кода через отражение в формальную конкретную модель. Рассказать подробнее о Store_Block/Load_Block идеологии,
    как обеспечивается их корректность через требование того, что блоки должны быть отражены в модели и модель должна быть
    корректной.

### Отражение отношения в Ghost-модель

Конечно, Store_Block/Load_Block явно недостаточно для верификации. Поэтому есть ещё функции и процедуры, которые выражают те или
иные связи между блоками (тут далеко не полный список):

  * Is_First_Block/Is_Last_Block - первый/последний в памяти
  * Next_Block_Address - адрес следующего в памяти блока
  * Neighbor_Blocks - два блока соседние
  * Get_Next_Block/Get_Prev_Block - получить следующий/предыдущий блок

Все эти отношение и функции имеют соответствующие отражения в Ghost-модели, а корректность отражений достигается соответствующими
предикатами в пре- и пост-условиях.
