Как разработать надёжное ПО?
Как сократить время на отладку или избежать отладки совсем?
Какие инструменты и методы можно применять для проектирования, разработки и анализа свойств ПО?
Как сформулировать и провалидировать функциональные (и архитектурные) свойства ПО до начала разработки кода?
Как разрабатывать и проверять формальные спецификации на функционал ПО?

Привет! Меня зовут Васил Дядов, и теперь я уже бывший программист Яндекса.

Сразу предвосхищу некоторые вопросы:
  * это было сугубо моё решение
  * нет, Яндекс не плохой, я по-прежнему его считаю одним из лучших мест для работы в IT-сфере в России
  * просто не смог найти для себя нормального применения в Яндексе и захотелось найти более подходящее место
    работы с более интересными (лично для меня) задачами и возможностями профессионального развития

Сейчас, пока я безработный :), у меня есть некоторый объём свободного времени, которым я решил воспользоваться,
чтобы доделать верифицированный аллокатор памяти (довольно давно собирался этим заняться), ну и заодно написать
цикл статей об этом, с целью показать на практическом примере использование современного инструментария
для инженерной разработки ПО.

Эта статья в каком-то смысле продолжает две предыдущих статьи: [Инженерный подход к разработке ПО](https://habr.com/ru/company/yandex/blog/457810/)
и [Инженерный подход к разработке ПО. От теории к практике](https://habr.com/ru/company/yandex/blog/471012/).

<cut />

# Введение

Это будет не статья, а цикл статей. Материала получится довольно много и хотелось бы его нормально объяснить.

Цикл статей будет хронологическим, по основным этапам разработки.

В данный момент времени работа над проектом ещё не закончена, и статьи будут появляться по мере продвижения работ.

Причина такого подхода довольно проста: я боюсь, что после завершения проекта у меня не будет достаточного количества свободного времени и мотивации, чтобы написать статьи.

Отслеживать работы над аллокатором можно в репозитории с исходниками: [ada-tlsf](https://github.com/vasil-sd/ada-tlsf).

Сам аллокатор я пишу на **Аде**, точнее её подмножестве для формальной верификации - **Spark**.

В принципе, тот же самый подход можно использовать и для написания аллокатора на **C** с использованием **Frama-C** для формальной верификации (возможно, в отдалённом будущем сделаю вариант и на верифицированном **C**).

Почему **Ada/Spark**?

Тут несколько причин. Основная - это наличие наиболее развитого инструментария для формальной верификации - **GNATprove** и пр. от [**AdaCore**](https://www.adacore.com/).
Этот инструментарий промышленного качества, широко использующийся в авионике, космосе и пр. Достаточно посмотреть на список [клиентов **AdaCore**](https://www.adacore.com/company/our-customers).

**Frama-C** неплохой проект, но во многом пока академический, не получивший широкого применения в промышленности, со всеми вытекающими отсюда проблемами: и ошибками, и отсутствием хорошей поддержки и тд.

Но ситуация быстро меняется, так как **AdaCore** активно обратила своё внимание на **C/C++** и движется в сторону поддержки нескольких языков в рамках одного проекта: **Ada/C/C++**.
Ну и соответственно будет развиваться серьёзная поддержка формальной верификации для **C/C++** кода, возможно на базе GNATprove.

# Функциональные требования к аллокатору

Требования к аллокатору довольно простые: он должен уметь инициализировать служебные структуры в заданной области памяти,
выделять блоки памяти произвольных размеров и освобождать их, возвращая в пул свободной памяти.

Кроме того, так как в прошлом я занимался embedded разработкой, то мне хотелось чтобы аллокатор обладал ещё двумя важными свойствами:
гарантированным временем отклика и простотой.

В качестве основного алгоритма был взят алгоритм работы **TLSF** аллокатора (Two Level Segregated Fit).
Подробнее можно почитать в оригинальной статье [TLSF: a New Dynamic Memory Allocator for Real-Time Systems](http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdf).

Сам алгоритм аллокации я детально расписывать не буду, так как он практически не отличается от описанного в статье.

# План статей

Так как статьи будут писаться постепенно, то и план, скорее всего, будет пересматриваться и корректироваться.

По мере написания статей они будут прилинковываться сюда.

## Часть 1. Общее описание подхода к верификации корректности аллокатора

В этой статье я постараюсь подробно объяснить общие принципы и подходы, которые я использовал для 
верификации аллокатора.

Особой конкретики в этой части не будет, основные детали будут в следующих частях.

## Часть 2. Формулировка свойств корректности. Абстрактная модель. Валидация свойств и операций

В этой части будут сформулированы и обоснованы свойства корректности аллокатора.

Так же будет подробно описана абстрактная модель и её формализация на **Alloy**.

Будет проведена валидация, приведены и объяснены её результаты.

## Часть 3. Конкретная модель для верификации кода. Свойства и операции.

В этой части будет введена уточняющая модель, которая уже и будет использоваться для верификации самого кода
аллокатора.

Так же будет показан процесс переноса свойств из абстрактной формальной модели в конкретную уточнённую.

Будут введены дополнительные свойства, вспомогательные отношение между блоками памяти и формальные условия коррекстности модели.

Будут описаны основные уточнённые реализации операций над моделью и доказано сохранение основных свойств этими
операциями.

## Часть 4. Реальный код. Верификация через отражение в модель.

Тут будет подробно расписан механизм верификации функциональной корректности реального кода аллокатора путём
отражения структур и операций в конкретную модель для верификации.

Будет доказано сохранение свойств функциональной корректности при работе аллокатора.

# Ссылки

Тут приведены основные ссылки. В соответствующих частях будут приведены ссылки и на другие источники, которые
позволят читателю лучше изучить и понять те или иные аспекты описываемых вещей.

## Алгоритм аллокатора памяти

  * [TLSF: a New Dynamic Memory Allocator for Real-Time Systems](http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdf)
    статья с оригинальным алгоритмом TLSF аллокатора

## Alloy

Тут дублирую для удобства ссылки из предыдущих статей.

  * [Alloy Analyzer](http://alloytools.org/) + [Higher-Order Alloy](https://aleksandarmilicevic.github.io/hola/)
    Инструменты для работы со спецификациями на языке **Alloy**.
  * [Online Tutorial](http://alloytools.org/tutorials/online/)
    Материал немного устарел, но может быть полезным для новичков.
  * [Tutorial Materials](http://alloytools.org/tutorials/day-course/)
    Обучающие материалы.

## Ada

### Материал по самому азыку

  * [How I learned to love Ada as a C++ developer - Maya Posch](https://www.youtube.com/watch?v=hgS_xPu8DyY)
    видео от разработчика на **C++**, познакомившегося с **Адой**
  * [Русскоязычный сайт по Аде](https://www.ada-ru.org/)
  * [Learn Ada](https://learn.adacore.com/)
    отличный ресурс для знакомства с Адой и SPARK
  * [Ada Programming](https://en.wikibooks.org/wiki/Ada_Programming)
    Wiki книга по язык. Далеко не всё описано, но основные вещи есть и довольно много хороших примеров.
  * [AdaCore Blog](https://blog.adacore.com/)
  * [Ada 2012 reference manual](http://docs.adacore.com/live/wave/arm12/html/arm12/arm12-TOC.html)

### Материал по верифицируемому подмножеству SPARK

  * [Securing the Future of Safety and Security of Embedded Software](https://www.youtube.com/watch?v=DZSSyWlsb28)
    про то, как **NVidia** стали использовать **SPARK** и какой выигрыш от этого получили
  * [Maximum Security Vision: Securing the Future of Safe Autonomous Driving](https://blogs.nvidia.com/blog/2019/02/05/adacore-secure-autonomous-driving/)
    небольшая запись о том, в каких областях **NVidia** собирается использовать **SPARK**
  * [AdaCore Blog #SPARK](https://blog.adacore.com/tag/SPARK)
    много интересных статей о применениях **SPARK**
  * [Intro To SPARK](https://learn.adacore.com/courses/intro-to-spark/index.html)
  * [SPARK by Example](https://github.com/tofgarion/spark-by-example)
    Репозиторий с большим количеством примеров на **SPARK**
  * [SPARK 2014 User’s Guide](http://docs.adacore.com/spark2014-docs/html/ug/)
  * [SPARK 2014 Reference Manual](http://docs.adacore.com/spark2014-docs/html/lrm/)

### Инструментарий разработки и верификации

  * [GNAT GPL Donwload](https://www.adacore.com/download)
    среда разработки на Ada и верификации SPARK - программ

## Верификация C/C++

  * [Frama-C](https://frama-c.com/)
    Фреймворк для работы с программами на **C/C++** позволяет как формально верифицировать программы
    так и анализировать различные свойства програм за счёт большого количества плагинов.
