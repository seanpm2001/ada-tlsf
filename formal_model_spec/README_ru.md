## Введение

Тут находится Alloy спеки на модель для верификации TLSF аллокатора.

Вкратце что это и для чего нужно.

В задачах верификации кода часто нужно доказать не только низкоуровневые свойства кода (диапазоны,
отсуствие переполенений буферов и тд), но и высокоуровневые. Например, нужно доказать свойства:
отсутствие утечек памяти, сохранение валидности структуры памяти и пр.

В рамках подхода Ada/SPARK + Gnatprove это частично решается введением формальной модели с помощью
Ghost (не попадающих в результирующий код) модулей, переменных, функций и пр.

И с помощью пред и пост-условий доказывается сохранение инвариантов формальной модели.
То есть, доказывается, что код не нарушает свойства формальной Ghost модели.

Но проблема заключается в том, что в рамках SPARK'а тяжело (а в ряде случаев и совсем невозможно)
проверить и доказать основные свойства самой формальной модели. Например, что выбранные нами инварианты
гарантируют всегда валидность структуры памяти и тд. Так же в рамках SPARK нет возможности быстро
проверять и отлаживать гипотезы высокого уровня, так как зачастую эти гипотезы выходят за рамки логики
первого порядка.

Есть несколько способов решения проблемы корректности выбранной формальной модели и исследования её свойств (
поиск нужных инвариантов и пр).

Самый надёжны (и самый трудоёмкий) - это формальное доказательство высокоуровневых свойств модели с использованием
ATP (automated theorem prover), наподобие Coq, Isabelle/HOL, HOL4, HOL-Light и пр.
Этот способ позволяет в рамках логики высшего порядка (HOL - higher-ordel logic) или эквивалентных ей конструкций
в зависимых типах (как в Coq), строго математически формулировать и доказывать разные свойства.
Тут требуется весьма хорошая специализированная математическая подготовка и довольно приличный объём времени,
так как доказательства свойств модели в ATP будут требовать большого объёма ручной работы.

Другой способ, который даёт хорошую гарантию надёжности, но при этом на порядки менее трудоёмкий и практически
полностью автоматический, - это использование model-checkers и model-finders. Инструменты этого класса позволяют
проверять свойства модели на ограниченных пространствах состояний (при использовании symbolic model-checkers с SAT/SMT
солверами, эти пространства состояний могут быть очень большими), просматривая все эти состояния до устаносленных
органичений. В случае отсутсвия контр-примеров к сформулированным свойствам в рамках достаточно больших
пространтсв состояний, мы можем быть довольно хорошо уверены в том, что свойства выполняются всегда.

Инструментов в категориях model-checkers/model-finders сейчас довольно много, многие из них очень хорошего
промышленного качества ([неполный список model-checkers](https://en.wikipedia.org/wiki/List_of_model_checking_tools) 
и [model-finder](https://en.wikipedia.org/wiki/Alloy_(specification_language))).

Из тех, что лично мне нравятся, могу назвать [TLA+/TLC](https://en.wikipedia.org/wiki/TLA%2B) и
[Alloy](https://en.wikipedia.org/wiki/Alloy_(specification_language)). TLA+ отлично подходит для
моделирование динамики(протоколы, синхронизация и пр), а Alloy для исследования структур и операций
над этими структурами. Они отлично дополнят друг-друга.

Так как спеки на формальную модель для TLSF в основном связаны со структурой памяти, то естественным образом
был выбран Alloy для спецификации и проверки свойств формальной модели.

## Основная идея формальной верицикации TLSF

Основная идея - это иметь набор базовых операций, для которых доказано сохранение основных инвериантов и
дальнейшая композиция более высоких функций из этих базовых операций с доказательством сохранения как
базовых safety инвариантов, так и более специфичных, связанных уже с особенностями этих высокоуровневых
функций (наприер, ограничение сверху на время отклика).

## Основные понятия и определения

Тут будут введены основные понятия используемые в модели, с пояснениями.

### Время

Alloy модули, где нужно моедлирование изменения состояний, параметризованы сигнатурой Time.

Это упорядоченное множество моментов времени. Так как нас не итересуют никакие совйства, кроме
упорядоченности, то решено было выбрать для моментов времени не числа, а абстрактную сигнатуру
и ввести на ней строгий линейный порядок с помощью модуля util/ordering.

Шагом для моделирования всех операций я выбрал T -> T.next, где T in Time. То есть шаг связывает
два последовательных момента времени, между которыми нет промежуточных. В данном случае это даёт
простую и понятную формализацию. Есть несколько основных способов моделирования динамики и в данном
случае я решил вбрать прямое моделирование на шагах T -> T.next, что является удобным и понятным
с точки зрения нашего восприятия процессов и времени.

### Адреса

Адреса вводятся в модуле **block** (файл **block.als**) как сигнатура **Addr** линейно упорядоченных
объектов, для которых задана операция сложения (**Add** : **UniqSize** -> **Addr**) адреса с размером
блока (**UniqSize**) и заданы несколько простых свойств этой операции:

  * Сложение адреса с любым размером блока даёт больший адрес
  * Добавление одного и того же размера не может приводить к разным адресам
  * Для последнего (самого старшего) адреса операция для любых размеров не возвращает результата
    (так как после старшего адреса нет адресов)
  * Если к двум разным адресам прибавим одинаковый размер, то должны получить разные адреса
  * Сложение адреса с разными размерами должно давать разные адреса

Тут может возникнуть вопрос: зачем вводить отдельные сигнатуры для адресов и размеров и задавать
свойства операции сложения, а не взять для них сигнатуру целых чисел **Int** для которой
все эти свойства автоматически выполняются?

Ответ:
  1. У нас есть последний адрес, для которого операция сложения не определена, для **Int** придётся
     вводить дополнительные условия проверки. И хоть это и не слишком сложно, но всё-таки не слишком
     понятно и очевидно.
  2. В Alloy довольно слабая проверка типов, и нельзя делать несовметимые (которые не приводятся друг к
     другу неявно) новые типы на основе базового, как в Ada/SPARK. Поэтому ошибки в виде перепутывания
     местами адреса и размера, сложение адресов (которое в данной модели не определено вообще, и это
     сделано специально) и пр. будут незамечены и потом можно будет потратить много времени на поиск
     и отладку. А так как Alloy не является классическим языком программирования, то отладка там
     весьма специфическая и иногда довольно проблематичная - приходится анализировать примеры и контр-примеры
     строить гипотезы, проверять их и иногда гонять на некоторых найденных моделях калькулятор выражений
     (Evaluator). Так что лучше писать спецификацию так, чтобы исключать как можно большие классы
     дурацких ошибок.

После полноценной отладки спецификации можно будет сигнатуры **Addr** и **UniqSize** сделать
производными от **Int**, чтобы убрать лишние факты и сделать спеку более читаемой.

Для удобства введён макрос Sum[left, right], который так же используется для размеров **UniqSize**.

### Размеры блоков

Размеры блоков моделируются сигнатурой **UniqSize**. На ней введён линейный порядок. **Uniq** - чтобы
было понятно, что они все разные, то есть это не столько размеры, сколько классы эквивалентности
размеров.

На размерах задана операция сложения (**Add** : **UniqSize** -> **UniqSize**) и определены следующие
свойства (которые делают эту операцию почти такой же как плюс для целых чисел):

  * сумма всегда больше слагаемых
  * прибавление одинакового размера к заданному размеру не должно приводить к разным размерам
  * добавление одного и того же размера к разным не должно приводить к одному размеру
  * от перестановки результат не меняется (операция коммутативна)
  * операция сложения размеров ассоциативна

Не все эти свойства нужны для модели, но для более понятного и удобного восприятия найденных примеров/контрпримеров
лучше, чтобы операция была максимально похожа по свойствам на операцию сложения целых чисел.

### Сами блоки

Блок объявлен как сигнатура **Block** с двумя отношениями: **Address: Addr -> Time** и **Size: UniqSize -> Time**.
То есть, адрес и размер блока могут меняться со временем. Это нужно для моделирования динамики.

Для блоков есть ещё ограничение, что адрес и размер должны либо одновременно присутствовать, либо одновременно
отсутствовать. По наличию/отсутствию адреса/размера блоки делятся на два класса - абстрактные и конкретные.

В рамках модели считается что все конкретные блоки должны быть в памяти упорядочены и покрывать всю область
памяти встык, то есть без промежутков (и не заползая друг на друга, естественно).

И соответственно это свойство и является основным инвариантом, который должен сохраняться при любых операциях
с блоками.

Этот инвариант даёт гарантию отсутсвия утечек памяти (между блоками нет областей памяти) и гарантию целостности
служебных структур (блоки не "заезжают" друг на друга, то есть при корректной работе с памятью в рамках одного блока
не затрагиваются другие блоки, тут корректность работы уже на совести пользовательского кода, аллокатор это
не может гарантировать, максимум - можно только проверок добавить, например контрольную сумму, чтобы детектировать
нарушения структур самого аллокатора)

Дополнительно ещё введены некоторые вспомогательные предикаты и функции, но их подробно здесь описывать не буду -
их можно посмотреть в исходниках.

### Списки свободных блоков

Каждый конкретный блок принадлежит одному из двух классов: либо классу свободных блоков, либо классу блоков
выделенных пользователю (занятых).

Соответственно для свободных блоков размеры делятся на классы эксивалентности (в рамках одного класса
эквиваелнтности блоки считаются близкими по размерам), в модели классы эквивалентности соответсвуют
атомам из **UniqSize**.

Для каждого класса размеров блоков есть список свободных блоков с размерами из этого класса.

Сигнатура свободных блоков - **FreeList**, определена в файле **freelist.als**

Для этой сигнатуры введены два отношения: **SizeClass: UniqSize** и **Blocks: set Block -> Time**.

Первое отношение совместно с дополнительными ограничениями задаёт соответствие 1-к-1 с **UniqSize**.

Второе отношение используется для того, чтобы задавать динамику изменения множества блоков в этом
списке свободных.

Кроме **FreeList** ещё введена сигнатура **BlockType** с двумя атомами: **Occupied** и **Free**.
И сигнатруа **Types** которая имеет единственный атом и отношние **Type: Block -> BlockType -> Time**,
которое с соответствующими наложенными ограничениями служит для того, чотбы задавать типы блоков и
моделировать их изменение во времени.

Основные инварианты для списков свободных блоков:

  * Тип может иметь только конкретный блок
  * Все свободные блоки в списках и кроме свободных блоков других в списках нет
  * Каждый свободный блок только в соответствующем (по классу размеров) списке свободных
  * Свободный блок может быть только в одном списке свободных

Эти инварианты должны сохраняться при любых операциях с блоками. Их выполнение гарантирует однозначную,
непртиворечивую и корректную работу со свободными блоками (нет потерянных блоков, нет ошибочно выбранных
не по размеру блоков и тд)

## Операции над блоками

Тут основные операции над блоками памяти. Каждая операция в своём файле. Для предиката каждой операции
есть ещё предикаты Pre и Post для того, чтобы моделирование было ближе к исходному коду и можно
было бы Pre/Post предикаты сразу перекладывать в пред и пост-условия к соответствующим функциям.

### Split

Файл: **op_split.als**

Операция для разделения свободного блока на два с заданными размерами. Эта операция будет использоваться,
когда нужного размера свободный блок под запрос пользователя не найден и нам нужно взять свободных большего
размера и разрезать на два мелких, один из которых потом отдадим под пользовательский запрос.

Соответственно эта операция должна обновить структуру памяти, обновить списки свободных, типы блоков и др.

### Join

Файл: **op_join.als**

Объединение двух смежных свободных блоков. Эта операция будет использоваться при возврате пользователем
блока памяти обатно в пул TLFS.

## Как это будет отражено в SPARK

### Модель в SPARK

#### Блоки
Блоки с адресами и размерами будем моделировать через Ada.Containers.Functional_Vector.

(todo: описать операции и объяснить,
       почему вся работа с блоками будет строиться через split и join операции)

## TODO

1. перевести на числа адреса и размеры после завершения разработки модели
2. Расписать подробно про модель
3. Свойства модели расписать
4. Как это будет в спарке
5. план доказательства корректности

