module address

-- адреса и размеры упорядочены
open util/ordering[Addr]
open util/ordering[UniqSize]

-- Реляционная спецификация модели для блоков
-- Адреса - множество уникальных объектов с линейным порядком
-- Размеры - множество уникальных объектов с линейныс порядком
-- Операции:
--    для адресной арифметики:
--        адрес + размер = адрес
--    для работы с размерами:
--        размер + размер = размер
-- Блоки памяти - множество уникальных объектов, характеризуются адресом и размером
-- Линейно упорядочены (порядок индуцирован адресами)
-- Закрывают всю память встык, то есть (кроме первого и последнего):
-- адрес предыдущего + его размер = адресу следующего
-- у первого нет предыдущего, у последнего - следующего

-- Основные инварианты, которые нужно сохранять, введя операции над блоками
-- 1. Сплошное покрытие блоками памяти, без "дыр", по-умолчению считаем, что
--    работаем с выровненными адресами и размерами и все блоки всегда впритык
-- todo, после введения списков свободных
-- 2. свободный блок может быть только в одном списке свободных
-- 3. нет свободных блоков вне списков свободных
-- 4. в списках свободных только свободные блоки.

let Sum [Left, Right] {
  Left.Add[Right]
}

sig Addr {
  -- тут вводим операцию сложения адреса с размером
  Add: UniqSize -> Addr
}

-- Зададим несколько основных свойств на сложение адресов и размеров
-- (не факт, что они все необходимы для корректной модели, но
--  для привычного восприятия точно нужны :) )

-- Сумма адреса и размера всегда должна быть больше этого адреса
fact {
  all Left : Addr - last
  | all Right : UniqSize 
  | let S = Sum[Left, Right]
  {
    gt[S, Left]
  }  
}

-- Добавление одинакового размера не должно приводить к разным адресам
fact {
  all A : Addr
  | all S : UniqSize
  | lone Sum[A, S]
}

-- Какой бы размер мы не прибавили к последнему адресу, следующий мы не получим
fact {
  no last.(Addr <: Add)
}

-- добавление одинакового размера к разным блокам должно приводить к разным адресам
fact {
  all A : Addr
  | all S : UniqSize
  | lone Add.A.S  
}

-- добавление разных размеров к адресу должно приводить к разным адресам

fact {
  all disj A1, A2 : Addr
  | lone A1.Add.A2
}

-- Тут уникальные упорядоченные размеры
sig UniqSize {
  -- тут вводим операцию сложения размеров
  Add : UniqSize -> UniqSize
}

-- Тут тоже зададим ограничения на Add, чтобы она выглядела привычнее

-- сложение: сумма всегда больше слагаемых
fact {
  all Left : UniqSize
  | all Right : UniqSize 
  | let S = Sum[Left, Right]
  {
    gt[S, Left]
    gt[S, Right]
  }
}

-- добавление одинакового размера не должно приводить к разным размерам
fact {
  all Left : UniqSize
  | all Right : UniqSize
  | lone Sum[Left, Right]  
}

-- добавление одного и того же размера к разным не должно приводить к одному размеру
fact {
  all Right : UniqSize
  | all Result : UniqSize
  | lone Add.Result.Right
}

-- от перестановки результат не меняется
fact {
  all Left : UniqSize
  | all Right : UniqSize
  | Sum[Left, Right] = Sum[Right, Left]
}

-- блок памяти
-- характеризуется адресом
-- и размером
sig Block {
    Address : disj one Addr,
    Size    : one UniqSize
}

-- Расположение блоков в памяти: друг за другом, без перекрытия
-- [ <- Size0 -> ][ <- Size1 -> ][ <- Size2 -> ]
-- ^              ^              ^
-- Addr0          Addr1          Addr2
--                Addr0 + Size0  Addr1 + Size1
--
-- Условие правильности адресов:
-- Кроме первого адреса все остальные являются сложением предыдущего с 
-- некоторым уникальным размером

fun FirstBlock : one Block { {B : Block | B.Address = min[Block.Address]} }
fun LastBlock : one Block { {B : Block | B.Address = max[Block.Address]} }

fact {
  -- у всех кроме последнего есть следующий
  all B : Block
  | B != LastBlock implies {
    one Address.(Sum[B.Address, B.Size])
  }
  -- у последнего нет следующего
  no Address.(Sum[LastBlock.Address, LastBlock.Size])
  -- у первого нет предыдущего
  FirstBlock.Address not in { 
    A : Addr
    | all B : Block 
    | A = Sum[B.Address, B.Size]
  }
  -- у каждого кроме первого есть предыдущий
  all B : Block - FirstBlock
  | one BPrev : Block - B
  | Sum[BPrev.Address, BPrev.Size] = B.Address
}

run {}  for 5 but 10 UniqSize, exactly 4 Block
